#!/usr/bin/python3
#
# Copyright 2012-2014 "Korora Project" <dev@kororaproject.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

import random, time

import dnf
import hawkey
import inspect
import json
import os
import signal
import subprocess
import sys
import threading
import urllib.request
import webbrowser

from Pharlap import detect
from Pharlap.DNFCache import DNFCache

# GTK
from gi.repository import WebKit2, Gtk, GObject

class _IdleObject(GObject.GObject):
  '''
  Override gobject.GObject to always emit signals in the main thread
  by emmitting on an idle handler
  '''
  def __init__(self):
    GObject.GObject.__init__(self)

  def emit(self, *args):
    GObject.idle_add(GObject.GObject.emit, self, *args)

class _FooThread(threading.Thread, _IdleObject):
  '''
  Thread which uses GObject signals to return information
  to the GUI.
  '''
  __gsignals__ = {
    "completed": ( GObject.SIGNAL_RUN_LAST, GObject.TYPE_NONE, []),
    "progress":  ( GObject.SIGNAL_RUN_LAST, GObject.TYPE_NONE, [GObject.TYPE_FLOAT])        #percent complete
  }

  def __init__(self, target=None, args=(), kwargs={}):
    threading.Thread.__init__(self, target=target, *args, **kwargs)
    _IdleObject.__init__(self)

    self.setDaemon(True)

  def run(self):
    threading.Thread.run(self)

    self.emit("completed")

class FooThreadManager():
  '''
  Manages many FooThreads. This involves starting and stopping
  said threads, and respecting a maximum num of concurrent threads limit
  '''
  def __init__(self, maxConcurrentThreads):
    self.maxConcurrentThreads = maxConcurrentThreads

    #stores all threads, running or stopped
    self.fooThreads = {}

    #the pending thread args are used as an index for the stopped threads
    self.pendingFooThreadArgs = []

  def _register_thread_completed(self, thread, *args):
    '''
    Decrements the count of concurrent threads and starts any
    pending threads if there is space
    '''
    del(self.fooThreads[args])
    running = len(self.fooThreads) - len(self.pendingFooThreadArgs)

    print("%s completed. %s running, %s pending" % (thread, running, len(self.pendingFooThreadArgs)))

    if running < self.maxConcurrentThreads:
      try:
        args = self.pendingFooThreadArgs.pop()
        print("Starting pending %s" % self.fooThreads[args])
        self.fooThreads[args].start()
      except IndexError: pass

  def make_thread(self, completedCb, progressCb, userData, target, *args, **kwargs):
    '''
    Makes a thread with args. The thread will be started when there is
    a free slot
    '''
    running = len(self.fooThreads) - len(self.pendingFooThreadArgs)

    if args not in self.fooThreads:
      thread = _FooThread(target=target, *args, **kwargs)

      #signals run in the order connected. Connect the user completed
      #callback first incase they wish to do something
      #before we delete the thread
      thread.connect("completed", completedCb, userData)
      thread.connect("completed", self._register_thread_completed, *args)
      thread.connect("progress", progressCb, userData)

      #This is why we use args, not kwargs, because args are hashable
      self.fooThreads[args] = thread

      if running < self.maxConcurrentThreads:
        print("Starting %s" % thread)
        self.fooThreads[args].start()

      else:
        print("Queing %s" % thread)
        self.pendingFooThreadArgs.append(args)

  def stop_all_threads(self, block=False):
    '''
    Stops all threads. If block is True then actually wait for the thread
    to finish (may block the UI)
    '''
    for thread in self.fooThreads.values():
      thread.cancel()
      if block:
        if thread.isAlive():
          thread.join()


class PharlapConfig(object):
  def __init__(self):
    self._modaliases = detect.system_modaliases()
    self._devices = {}
    self._loaded_modules = {}

    # store full path to our binary
    self._pharlap_bin_path = os.path.abspath(inspect.getfile(inspect.currentframe()))

    # store directory to our pharlap configuration
    self._config_dir = os.path.expanduser('~/.config/korora/pharlap/')

    # store full path to our autostart symlink
    self._autostart_path = os.path.expanduser('~/.config/autostart/korora-pharlap.desktop')

    # ensure our config directory exists
    if not os.path.exists( self._config_dir ):
      try:
        os.makedirs( self._config_dir )
      except OSError as e:
        pass

    # does autostart symlink exist
    self._autostart = os.path.exists( self._autostart_path )


  def post_init(self):
    db = dnf.base()
    self._dnf_cache = dnfcache(db)


  def reload_devices(self):
    self._devices = detect.system_driver_packages(cache=self._dnf_cache, modaliases=self._modaliases)

  def reload_loaded_modules(self):
    self._loaded_modules = detect.loaded_modules_for_modaliases(modaliases=self._modaliases)

  @property
  def autostart(self):
    return self._autostart

  @autostart.setter
  def autostart(self, state):
    if( state and not os.path.exists( self._autostart_path ) ):
      # create the autostart symlink
      try:
        os.symlink( '/usr/share/applications/korora-pharlap.desktop', self._autostart_path )
      except OSError as e:
        pass
    elif( not state and os.path.exists( self._autostart_path ) ):
      # remove the autostart symlink
      try:
        os.unlink( self._autostart_path )
      except OSError as e:
        pass

    # determine autostart state based on absence of the disable file
    self._autostart = os.path.exists( self._autostart_path )

  def toDict(self):
    return {
      'devices':        self._devices,
      'modaliases':     self._modaliases,
      'loaded_modules': self._loaded_modules,
    }

class KororaAppView(WebKit2.WebView):
  def __init__(self):
    WebKit2.WebView.__init__(self)

    self.manager = FooThreadManager(3)

    # load the config object
    self._config = PharlapConfig()

    # register signals
    self.connect('load-changed', self._load_changed_cb)
    self.connect('decide-policy', self._decide_policy_cb)
    self.connect('notify::title', self._title_changed_cb)

    self.l_uri = None

    # disable right-click context menu
    #self.get_settings().set_property('enable-default-context-menu', False)

  def _push_data(self, key, value):
    self.run_javascript("app_rs.$apply( function() { app_rs.$broadcast('configUpdate', '%s', %s) });" % (k, json.dumps(v)), None, None, None)

  def _push_config(self):
    # we externaly inject a broadcast of the configUpdate event, wrapped in apply for angular's satisifaction
    self.run_javascript("app_rs.$apply( function() { app_rs.$broadcast('configUpdate', 'config', %s) });" % json.dumps(self._config.toDict()), None, None, None)

  def _load_changed_cb(self, view, event):
    if event == WebKit2.LoadEvent.FINISHED:
      # push config on every page load
      self._push_config()

  def _title_changed_cb(self, view, event):
    cmd = view.get_title()

    if cmd is None:
      return

    try:
      c = json.loads(cmd)
    finally:
      return

    self._do_command(c)

  def _decide_policy_cb(self, view, decision, decision_type):
    if decision_type == WebKit2.PolicyDecisionType.NAVIGATION_ACTION:

      # grab the requested URI
      uri = decision.get_request().get_uri()

      # TODO: improve separation of HTML5 hash bang versus inline anchors
      try:
        if uri.index('#') > 0:
          uri = uri[:uri.index('#')]
      except ValueError as e:
        pass

      # don't reload ourself ( side effect of managing inline anchors )
      if uri == self.l_uri:
        return
      # TODO: end

      # process command URIs
      if uri.startswith('cmd://'):
        self._do_command(uri)
        decision.ignore()
        return

      # process absolute URIs
      # open links in a new tab in the default browser
      if uri.startswith("http://") or \
         uri.startswith("https://"):
        decision.ignore()
        webbrowser.open_new_tab(uri)
        return

      # store the requested URI for self checks
      self.l_uri = uri

      # we have a legitimate page so let's load
      page = urllib.request.urlopen(uri)

  def thread_finished(self, thread, rowref):
    self._push_config()

  def thread_progress(self, thread, progress, rowref):
    pass

  def _do_command(self, call):
    if not isinstance(call, dict):
      return

    cmd = call.setdefault('c', '')
    args = call.setdefault('a', [])

    if( cmd == 'reload_devices' ):
      self.manager.make_thread( self.thread_finished, self.thread_progress, None, self._config.reload_devices)

    if( cmd == 'reload_modules' ):
      self.manager.make_thread( self.thread_finished, self.thread_progress, None, self._config.reload_modules)

    elif( cmd == 'close' ):
      Gtk.main_quit();

    else:
      print('Unknown commanad specified: %s' % uri)


class PharlapApp(object):
  def __init__(self):

    # establish our location
    self._location = os.path.dirname( os.path.abspath(inspect.getfile(inspect.currentframe())) )

    # check for relative path
    if( os.path.exists( os.path.join(self._location, 'data/' ) ) ):
      print('Using relative path for data source. Non-production testing.')
      self._data_path = os.path.join(self._location, 'data/')
    elif( os.path.exists('/usr/share/pharlap/') ):
      self._data_path = '/usr/share/pharlap/'
    else:
      print('Unable to source the pharlap data directory.')
      sys.exit(1)

    # build the app window
    self._build_app()

  def _build_app(self):
    file = os.path.abspath( os.path.join( self._data_path, 'index.html') )
    uri = 'file://' + urllib.request.pathname2url(file)

    # build window
    w = Gtk.Window()
    w.set_position(Gtk.WindowPosition.CENTER)
    w.set_wmclass('Pharlap', 'Pharlap')
    w.set_title('Pharlap')
    w.set_size_request(792, 496)

    # build webkit container
    kv = KororaAppView()

    # load our index file
    kv.load_uri(uri)

    # TODO: Move to AppView

    # build scrolled window widget and add our appview container
    sw = Gtk.ScrolledWindow()
    sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
    sw.add(kv)

    # build an autoexpanding box and add our scrolled window
    b = Gtk.VBox(homogeneous=False, spacing=0)
    b.pack_start(sw, expand=True, fill=True, padding=0)

    # add the box to the parent window and show
    w.add(b)
    w.connect('delete-event', self.close)
    w.show_all()

    self._window = w
    self._appView = kv

  def run(self):
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    Gtk.main()

  def close(self, p1, p2):
    Gtk.main_quit(p1, p2);


app = PharlapApp()
app.run()

